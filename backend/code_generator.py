# ============================================================
# backend/code_generator.py — Workflow → Flask Code Generator
# ============================================================
# This module converts a workflow JSON into:
#   1. Human-readable Flask route source code (for "Export Code")
#   2. OpenAPI/Swagger spec fragment (for auto-docs)
#
# The generated code is for EXPORT purposes only — deployed
# endpoints use the workflow engine interpreter instead.
# ============================================================

import json


def generate_flask_code(workflow):
    """
    Generate a standalone Flask route function as a Python string.

    The output is a complete, runnable snippet that the user can
    copy into their own Flask project.

    Args:
        workflow (dict): Full workflow document.

    Returns:
        str: Python source code for the route.
    """
    name = workflow.get('name', 'untitled')
    # Sanitize name for use as Python function name
    func_name = name.replace('-', '_').replace(' ', '_').lower()
    blocks = workflow.get('blocks', [])

    lines = [
        f'# ============================================================',
        f'# Auto-generated Flask route for workflow: {name}',
        f'# ============================================================',
        f'# Generated by Low-Code API Builder Platform',
        f'# ============================================================',
        f'',
        f'from flask import Flask, request, jsonify',
        f'from pymongo import MongoClient',
        f'import requests',
        f'',
        f'app = Flask(__name__)',
        f'client = MongoClient("mongodb://localhost:27017/api_builder")',
        f'db = client["api_builder"]',
        f'',
        f'',
        f'@app.route("/api/{func_name}", methods=["POST", "GET"])',
        f'def {func_name}():',
        f'    """',
        f'    {workflow.get("description", "Auto-generated endpoint")}',
        f'    """',
        f'    # Get incoming request data',
        f'    request_data = request.get_json(silent=True) or {{}}',
        f'',
    ]

    # Generate code for each block
    for i, block in enumerate(blocks):
        block_type = block.get('type', '')
        block_id = block.get('id', f'block_{i}')
        config = block.get('config', {})
        var_name = f'result_{block_id[:8]}'

        lines.append(f'    # --- Block: {block.get("label", block_type)} ({block_type}) ---')

        if block_type == 'input':
            schema = config.get('schema', {})
            lines.append(f'    # Validate input against schema: {json.dumps(schema)}')
            for field, ftype in schema.items():
                lines.append(f'    assert "{field}" in request_data, "Missing field: {field}"')
            lines.append(f'    {var_name} = request_data')

        elif block_type == 'db_query':
            collection = config.get('collection', 'default')
            operation = config.get('operation', 'find')
            query = json.dumps(config.get('query', {}))
            lines.append(f'    collection = db["{collection}"]')
            if operation == 'find':
                limit = config.get('limit', 100)
                lines.append(f'    cursor = collection.find({query}).limit({limit})')
                lines.append(f'    {var_name} = []')
                lines.append(f'    for doc in cursor:')
                lines.append(f'        doc["_id"] = str(doc["_id"])')
                lines.append(f'        {var_name}.append(doc)')
            elif operation == 'find_one':
                lines.append(f'    {var_name} = collection.find_one({query})')
                lines.append(f'    if {var_name}:')
                lines.append(f'        {var_name}["_id"] = str({var_name}["_id"])')
            elif operation == 'insert':
                data = json.dumps(config.get('data', {}))
                lines.append(f'    result = collection.insert_one({data})')
                lines.append(f'    {var_name} = {{"inserted_id": str(result.inserted_id)}}')
            elif operation == 'delete':
                lines.append(f'    result = collection.delete_many({query})')
                lines.append(f'    {var_name} = {{"deleted_count": result.deleted_count}}')

        elif block_type == 'api_call':
            url = config.get('url', '')
            method = config.get('method', 'GET')
            lines.append(f'    response = requests.{method.lower()}("{url}", json=request_data, timeout=30)')
            lines.append(f'    {var_name} = response.json()')

        elif block_type == 'logic':
            condition = config.get('condition', 'True')
            lines.append(f'    # Condition: {condition}')
            lines.append(f'    if True:  # TODO: implement condition evaluation')
            lines.append(f'        {var_name} = {json.dumps(config.get("true_value", True))}')
            lines.append(f'    else:')
            lines.append(f'        {var_name} = {json.dumps(config.get("false_value", False))}')

        elif block_type == 'transform':
            lines.append(f'    # Transform data')
            lines.append(f'    {var_name} = request_data  # Apply transformations here')

        elif block_type == 'output':
            status_code = config.get('status_code', 200)
            body = json.dumps(config.get('body', {}))
            lines.append(f'    return jsonify({body}), {status_code}')

        lines.append(f'')

    # If no output block generated a return, add a default
    if not any(b.get('type') == 'output' for b in blocks):
        lines.append(f'    return jsonify({{"message": "Workflow executed successfully"}}), 200')

    lines.extend([
        f'',
        f'',
        f'if __name__ == "__main__":',
        f'    app.run(debug=True, port=5000)',
    ])

    return '\n'.join(lines)


def generate_openapi_spec(workflow):
    """
    Generate an OpenAPI 3.0 path spec fragment for a single workflow.

    This is used by the docs route to build the full Swagger spec
    by stitching together specs from all deployed workflows.

    Args:
        workflow (dict): Full workflow document.

    Returns:
        dict: OpenAPI path object for this workflow's endpoint.
    """
    name = workflow.get('name', 'untitled')
    description = workflow.get('description', 'Auto-generated endpoint')
    blocks = workflow.get('blocks', [])

    # Build request schema from input blocks
    request_properties = {}
    required_fields = []

    for block in blocks:
        if block.get('type') == 'input':
            schema = block.get('config', {}).get('schema', {})
            for field_name, field_type in schema.items():
                openapi_type = _python_type_to_openapi(field_type)
                request_properties[field_name] = {'type': openapi_type}
                required_fields.append(field_name)

    # Build response schema from output blocks
    response_properties = {}
    for block in blocks:
        if block.get('type') == 'output':
            body = block.get('config', {}).get('body', {})
            for key, value in body.items():
                if isinstance(value, str) and '{{' in value:
                    response_properties[key] = {'type': 'string', 'description': f'Dynamic: {value}'}
                else:
                    response_properties[key] = {'type': _infer_openapi_type(value)}

    # Construct the path object
    path_spec = {
        'post': {
            'summary': name,
            'description': description,
            'tags': ['Generated APIs'],
            'requestBody': {
                'required': bool(request_properties),
                'content': {
                    'application/json': {
                        'schema': {
                            'type': 'object',
                            'properties': request_properties,
                            'required': required_fields,
                        }
                    }
                }
            },
            'responses': {
                '200': {
                    'description': 'Successful response',
                    'content': {
                        'application/json': {
                            'schema': {
                                'type': 'object',
                                'properties': response_properties if response_properties else {
                                    'result': {'type': 'object', 'description': 'Workflow output'}
                                },
                            }
                        }
                    }
                },
                '400': {
                    'description': 'Validation error',
                    'content': {
                        'application/json': {
                            'schema': {
                                'type': 'object',
                                'properties': {
                                    'error': {'type': 'string'}
                                }
                            }
                        }
                    }
                },
                '500': {
                    'description': 'Execution error',
                }
            }
        }
    }

    return path_spec


# ============================================================
# Helper Functions
# ============================================================

def _python_type_to_openapi(type_str):
    """Map our schema type names to OpenAPI type names."""
    mapping = {
        'string':  'string',
        'number':  'number',
        'integer': 'integer',
        'boolean': 'boolean',
        'array':   'array',
        'object':  'object',
    }
    return mapping.get(type_str, 'string')


def _infer_openapi_type(value):
    """Infer an OpenAPI type from a Python value."""
    if isinstance(value, bool):
        return 'boolean'
    if isinstance(value, int):
        return 'integer'
    if isinstance(value, float):
        return 'number'
    if isinstance(value, list):
        return 'array'
    if isinstance(value, dict):
        return 'object'
    return 'string'
